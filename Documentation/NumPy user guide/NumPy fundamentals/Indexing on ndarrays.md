# Indexing on [`ndarrays`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")

**Seel also**
[Indexing routines](https://numpy.org/doc/stable/reference/arrays.indexing.html#routines-indexing)

[`ndarrays`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray") can be indexed using the standard Python `x[obj]` syntax, where _x_ is the array and _obj_ the selection. There are different kinds of indexing available depending on _obj_: basic indexing, advanced indexing and field access.

Most of the following examples show the use of indexing when referencing data in an array. The examples work just as well when assigning to an array. See [Assigning values to indexed arrays](https://numpy.org/doc/stable/user/basics.indexing.html#assigning-values-to-indexed-arrays) for specific examples and explanations on how assignments work.

Note that in Python, `x[(exp1, exp2, ..., expN)]` is equivalent to `x[exp1, exp2, ..., expN]`; the latter is just syntactic sugar for the former.

## Basic indexing 

### Single element indexing 

Single element indexing works exactly like that for other standard Python sequences. It is 0-based, and accepts negative indices for indexing from the end of the array.

```python
>>> x = np.arange(10)
>>> x[2]
2
>>> x[-2]
8
```

It is not necessary to separate each dimension's index into its own set of square brackets.

```python
>>> x.shape = (2, 5) # now x in 2-dimensional
>>> x
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> x[1, 3]
8
>>> x[1, -1]
9
```

Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:

```python
>>> x[0]
array([0, 1, 2, 3, 4])
```

That is, each index specified select the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is a [view](https://numpy.org/doc/stable/glossary.html#term-view), i.e., it is not a copy of the original, but points to the same values in memory as does the origianl array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:

```python
>>> x[0][2]
2
>>> x[0, 2]
2
```

So note that `x[0, 2] == x[0][2]` though the second case is more inefficient as a new temporary array is created after the first index that is subsequently indexed by 2.

**Note**

NumPy uses C-order indexing. That means that the last index usually represents the most rapidly chaning memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion.

### Slicing and striding

Basic slicing extends Python's basic concept of slicing to N dimensions. Basic slicing occurs when *obj* is a [`slice`](https://docs.python.org/3/library/functions.html#slice "(in Python v3.11)") object (constructed by `start:stop:step` notation inside of brackets), an integer, or a tuple of slice objects and integers. [`Ellipsis`](https://docs.python.org/3/library/constants.html#Ellipsis "(in Python v3.11)") and [`newaxis`](https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis "numpy.newaxis") objects can be interspersed with these as well.

The simplest case of indexing with *N* integers returns an [array scalar](https://numpy.org/doc/stable/reference/arrays.scalars.html#arrays-scalars) represents the corresponding item. As in Python, all indices are zero-based: for the *i*-th index $n_i$, the valid range is $0 \leq n_i < d_i$ where $d_i$ is the *i*-th element of the shape of the array. Negative indices are interpreted as counting from the end of the array (i.e., if $n_i < 0$, it means $n_i + d_i$).

All arrays generated by basic slicing are always [views](https://numpy.org/doc/stable/glossary.html#term-view) of the original array.

**Note**

 NumPy slicing creates a [view](https://numpy.org/doc/stable/glossary.html#term-view) instead of a copy as in the case of built-in Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit `copy()` is recommended.

The standard rules of sequence slicing and apply to basic slicing on a per-dimension basic (including using a step index). Some useful concepts to remember include:

- The basic slice syntax is `i:j:k` where *i* is the starting index, *j* is the stopping index, and *k* is the step ($k \neq 0$). This selects the *m* elements (in the corresponding dimension) with index values *i, i + k, ..., i + (m - 1)k* where $m = q + (r \neq 0)$ and *q* and *r* are the quotient and remainder obtained by dividing *j - i* by *k: j - i = q k + r,* so that *i + (m - 1)k < j*. For example:

```python
>>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> x[1:7:2]
array([1, 3, 5])
```

- Negative *i* and *j* are interpreted as *n + i* and *n + j* where *n* is the number of elements in the corresponding dimension. Negative *k* makes stepping go towards smaller indices. From the above example:

```python
>>> x[-2:10]
array([8, 9])
>>> x[-3:3:-1]
array([7, 6, 5, 4])
```

- Assume *n* is the number of elements in the dimension being sliced. Then if *i* is not given it defualts to 0 for *k > 0* and *n - 1* for *k < 0*. If *j* is not given it defaults to *n* for *k > 0* and *-n-1* for *k < 0*. If *k* is not given it defaults to 1. Note that `::` is the same as `:` and means select all indices along the axis. From the above example:

```python
>>> x[5:]
array([5, 6, 7, 8, 9])
```

- If the number of objects in the selection tuple is less than *N*, then `:` is assumed for any subsequent dimensions. For example:

```python
>>> x = np.array([[[1], [2], [3]], [[4], [5], [6]]])
>>> x.shape
(2, 3, 1)
>>> x[1:2]
array([[[4],
        [5],
        [6]]])
```

- An integer, *i*, returns the same values as `i:i+1` *excpet* the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the _p_-th element an integer (and all other entries `:`) returns the corresponding sub-array with dimension _N - 1_. If _N = 1_ then the returned object is an array scalar. These objects are explained in [Scalars](https://numpy.org/doc/stable/reference/arrays.scalars.html#arrays-scalars).

- If the selection tuple has all entries `:` except the _p_-th entry which is a slice object `i:j:k`, then the returned array has dimension _N_ formed by concatenating the sub-arrays returned by integer indexing of elements _i_, _i+k_, …, _i + (m - 1) k < j_,

- Basic slicing with more than one non-`:` entry in the slicing tuple, acts like repeated application of slicing using a single non-`:` entry, where the non-`:` entries are successively taken (with all other non-`:` entries replaced by `:`). Thus, `x[ind1, ..., ind2,:]` acts like `x[ind1][..., ind2, :]` under basic slicing.

**Warning**

The above is **not** true for advanced indexing.

- You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in `x[obj] = value` must be (broadcastable to) the same shape as `x[obj]`.

- A slicing tuple can always be constructed as _obj_ and used in the `x[obj]` notation. Slice objects can be used in the construction in place of the `[start:stop:step]` notation. For example, `x[1:10:5, ::-1]` can also be implemented as `obj = (slice(1, 10, 5), slice(None, None, -1)); x[obj]` . This can be useful for constructing generic code that works on arrays of arbitrary dimensions. See [Dealing with variable numbers of indices within programs](https://numpy.org/doc/stable/user/basics.indexing.html#dealing-with-variable-indices) for more information.

